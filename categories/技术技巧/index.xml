<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术技巧 on Kuhung&#39;s Blog</title>
    <link>https://kuhungio.me/categories/%E6%8A%80%E6%9C%AF%E6%8A%80%E5%B7%A7/</link>
    <description>Recent content in 技术技巧 on Kuhung&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 25 May 2021 21:53:20 +0800</lastBuildDate>
    
	<atom:link href="https://kuhungio.me/categories/%E6%8A%80%E6%9C%AF%E6%8A%80%E5%B7%A7/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>程序员该如何做好观点、技术与产品方案的销售</title>
      <link>https://kuhungio.me/2021/selling-the-wheel/</link>
      <pubDate>Tue, 25 May 2021 21:53:20 +0800</pubDate>
      
      <guid>https://kuhungio.me/2021/selling-the-wheel/</guid>
      <description>概述 实际发布 最后一次修改     通俗易懂的营销故事 20210601 20210601     在互联网行业，常常听见人说：我有个点子，只是缺少一个程序员，就能颠覆世界。不过遗憾的是，很多组织即使有很多程序员，也未能颠覆世界。无数的点子被证明是无效的，无人买单。用户不关心、客户不掏钱。
上面是普通人的技术产品主张。作为程序员自己，是不是就没有这样的困扰了呢？我们可以做前端、可以做web端、可以开发自己的小程序，是不是就可以吸引无数忠实用户、卖个好价钱、躺平后半生了呢？如果真是这样子，那大概996和秃头就是假的、是拜登打的劳工牌了。
除了技术力，市场的敏锐度以及营销能力，也是决定成败的关键。
在日常工作中，不可避免的，程序开发也会有自己的观点主张：无论是技术方面的、还是日常决策方向的。也有人幻想着，有个赏识的伯乐，能发现自己点子的独特之处，然后悄悄”颠覆世界“。
技术同事能听出哪些点子是不现实的，同样，”伯乐“也能识别出你的技术主张的好坏。这个时候该怎么办呢，产品太超前、主张太激进，难道就去不推销了吗？求人不如求己。
推销是一门艺术。作为价值提供者，我们有必要做好自己的营销推广。除非，你想一直当一个工具人下去。我们希望，在合适的推销之下，产品能卖出去、技术方案能得到接纳，观点主张能得到重视。这一切，其实都不难。
 近期阅读了一本名为《selling the wheel》（中文名《卖轮子》）的书，该书虚拟架空了一个埃及人卖轮子的故事。讲述从发明轮子，到销售推广，再到竞争市场的各个环节。以及对应市场下，如何构建适合的销售体系。这套方法，不仅可以用来卖产品，完全也可以整合到我们自身的日常生活中来，销售我们的观点、技术与方案。
如果你也想做好自身观点、技术和产品的宣传，那么下面的内容一定不要错过。
 市场上没有一套通吃的办法。这是因为随着市场成熟度的不同，受众和他们的认知程度也不一样。但好在在不同阶段，有各自能做的事。我们以产品的发展周期为例，讲述四个时间段我们该做的事情。
①市场早期 当市场还是蓝海之时，很少有人意识到这是个机会。客户也是同样如此，他不会觉得有你很重要。因为当你没出现时，他已经按某种模式度过了很多年。在轮子出现前，古埃及人一样可以运送货物。他们可以选择用人拉、用动物驮，甚至是用雪橇拉。为什么他们要选择你呢？
在产品的早期，往往是一些尝鲜的用户接纳它们。在四步创业中，我们也可称之为天使用户。在技术接纳生命周期中，他们是技术和产品的尝鲜者。天使用户乐于追逐新鲜事物，是你最好的销售目标。他们聪明、敢于尝鲜，敢冒险，有资本。
销售对象是最高决策者，一般是一次性买卖。如果想要卖给他们，则应该强调某些特质，而这些正是他们所追逐的：领先于人的机会和洞察，一个更高效的、更美好的未来。对于销售者，则是需要极强的人格魅力。相信产品，用华丽的演示征服他人。
新技术、新产品、新观念 这一阶段，是我们最常遇到的阶段，特别是进入新公司和新项目中时。技术人员在公司内拥有较为时髦的技术，知道当下技术发展的潮流。也因为掌握技术，能较为轻易的了解到最新潮的观念。以数据挖掘为例，我们有很多模型方法，已经在顶刊、比赛甚至是其它公司的业务场景中得到应用。
在公司内进行推广时，往往不会一帆风顺。因为当你没出现时，业务方已经熟练的用其它方法解决了问题，尽管它可能没你的好。
这个时候，同上面一样，我们要去识别公司内的那些天使客户，将技术的前景销售给他们，打开应用市场。该阶段，我们常常是单兵作战，将我们的方案推销给有决策权、聪明且有冒险精神的业务方。推销一种概念，而不是一种产品或服务。以理性阐释购买，以情感卖出产品。
 ②市场发育 渐渐地，天使用户口碑传播了你的产品（只要你的产品值得他向朋友推荐）。越来越多的用户开始使用你的产品，他们会拿来做不同的用途，甚至有些超乎你意料。轮子是好的交通工具，但同时，两个石头轮子叠在一起，他也可以拿来做磨坊，高效地碾碎玉米。产品被越来越多的高层技术人员使用。他们不再是单一的拿来应用，而是借助产品，实现他们的整体目标。
所以，单纯的轮子已经不够用了。金字塔的建造工程师希望我们给到完成的方案，能够支持他们建设金字塔的工作。我们不再是仅仅销售轮子，更是在于轮子的安装、使用、保养等专业性知识。我们的销售对象，也不再局限于直接最高决策者，而是所有影响决策的人，与团队合作。我们销售的是整体解决方案，而不再是单一的产品，客户需要一整套方案，帮助他们实现美好目标。
在这种背景下，常常需要一个团队来支持。提供产品的售后、服务以及培训等事宜。销售周期也更长。我们就像是向导，不仅需要告诉客户目标在哪里，还要引导和带领他们。销售产品的同时，培训客户，构建良好的合作伙伴关系。
全套解决方案 在公司内也是如此，当我们的方案被更多人接纳时，将会出现不一样的需求和用户。有的可能只是单纯的需要个分类工具，有的开始拿你的产品或技术做其它的事情。我们不再是单打独斗，常常需要一个小团队一起工作，帮助业务方完成整体目标。
这个阶段，业务方需要的也不是单一的技术或工具，他们希望你去培训他们掌握该项技能、或是能提供长久的维护。所以，尽量提供更多的支持，帮助业务方实现共同目标。从目标出发，落地到对方的业务价值，能帮助你做出正确的决策。提供适当指引和培训，构建良好的合作关系，是当下阶段的重点。
这个阶段最大风险是花费资源做没有被接受的技术。为了减少风险，可以采取如下方式：适当地多同步进展，寻求业务方的反馈，根据反馈及时进行资源调整。
 ③市场竞争 产品是打开了销路，但不可避免的，你会和其它产品产生替代性冲突。更甚至，市面上开始出现仿冒的产品。轮子开始出现木制、出现条幅。他们更灵活、更便宜，技术不再是唯一的壁垒。大家也逐渐熟悉了有你的日子，但不同产品间仍有细微差别。这个时候，你的销售对象，应该是稳定的采购单位。他们在各大组织和机构中，你们在之前应该已经建立了稳固的合作关系。
客户开始有了其它需要满足的诉求，产品在这个阶段开始出现定制化。我们如同建设者，为我们最核心的客户，提供最优质的服务。尽管在第一阶段，天使客户也有可能提出他的各种想法，但真正值得响应的，却是这个阶段。因为在初期阶段，满足少量的额外需求，很可能带来频繁的调整以至于产品走向错误。一般客户只获得一般服务。
这个阶段，产品销售的周期大幅度拉长。产品开始同质化、价格战开始出现，利润下降。树立自己的品牌、扩大生产规模，是维持利润的两种手段。有些市场你已经撼动不了，短时间插足不了。但记得保持关注，竞争对手犯错之时，就是你最好的机会。
定制服务与品牌传播 在公司一段时间之后，只要你平稳度过前面两个阶段，大概率也会到这个阶段。你的技术方案、你的产品很可能同别的团队产生可替代性竞争。同时也被越来越多的人员和团队使用。
这个阶段，我们得针对需求方，提供定制化服务。通过评估核心重要程度和ROI，去满足他们的定制化需求。
树立团队口碑，扩大影响力，是获得需求的来源之一。压缩成本和工期，一味迎合所有业务方，是失败的快速通道。**你的团队伙伴，是你的重要资产和坚实靠山。**对于一些暂时无法接入的业务，维护好和客户的关系，等待机会即可。
 ④市场支配 最后阶段，即是红海市场。这也属我们所接触的民用消费市场最典型。产品出现同一标准，轮子有了半径、材质、使用寿命等要求。顾客不再像早期顾客，犹豫徘徊。他们很快做出决策，而他们所依赖的，则是品牌和服务。
这个阶段，利润被进一步摊薄。产品的品牌和服务成为了竞争的主要手段。促销开始越来越常见，连锁经验、标准化服务成为标配。
由销售leader领导的销售团队，提供细致的售前和售后服务。进行充分技术培训，激发员工热情，能妥善应对突发事件。
个人品牌与综合素质 如果你的公司不是toB业务，那么较小概率会到这一步。对于平台、中台类项目，更多的还是在上一步。如果你在此类公司，那么标准化服务可能是你重点关注的东西。
但是换个角度，如果我们抽离产品和公司的框架，我们的观点和主张所处的环境，难道不是在充分竞争的市场中吗？普世价值和道德选择，都有基本的标准。沟通的对象很快做出决策，依赖你的声誉和给人的感受。
过硬的专业素质，热情，同理心，以及移情的能力，就是你的标准化服务。你的个人品牌和综合素质，成为你的竞争利器。
 产品阶段组合 以上四种方式可以组合。
1+2 适合小而灵活的创业公司，技术进步，创业不歇。</description>
    </item>
    
    <item>
      <title>Xgboost 三种特征重要性计算方法对比与扩展</title>
      <link>https://kuhungio.me/2021/three-feature-importances-in-xgb/</link>
      <pubDate>Mon, 08 Mar 2021 21:09:31 +0800</pubDate>
      
      <guid>https://kuhungio.me/2021/three-feature-importances-in-xgb/</guid>
      <description>简单描述 实际发布 最后一次修改     xgb 特征重要性计算方法及使用场景 2021-03-08 2021-03-09    特征重要性 作用与来源 特征重要性，我们一般用来观察不同特征的贡献度。排名靠前的，我们自然而然地认为，它是重要的。
这一思路，通常被用来做特征筛选。剔除贡献度不高的尾部特征，增强模型的鲁棒性的同时，起到特征降维的作用。
另一个方面，则是用来做模型的可解释性。我们期望的结果是：重要的特征是符合业务直觉的；符合业务直觉的特征排名靠前。
在实际操作中，我们一般用树模型的分类节点做文章。常用的就是 XGB 和其他一般树模型。
XGB 遇到的问题 XGB 很方便，不仅是比赛的大杀器，甚至贴心的内置了重要性函数。但在实际使用过程中，常常陷入迷思。
有如下几个点的顾虑：
 这些特征重要性是如何计算得到的？ 为什么特征重要性不同？ 什么情况下采用何种特征重要性合适？   今天我们就借这篇文章梳理一下。
XGB 中常用的三种特征重要性计算方法，以及它的使用场景。除此之外，再看两个第三方的特征重要性计算方法，跳出内置函数，思考其中的差异。
最后回到类似的树模型特征计算方法，进行特征重要性的一般方法总结。
以下场景非特殊说明，均针对 python 包体下的 xgb 和sklearn。
XGB 内置的三种特征重要性计算方法1 weight xgb.plot_importance 这是我们常用的绘制特征重要性的函数方法。其背后用到的贡献度计算方法为weight。
 ‘weight’ - the number of times a feature is used to split the data across all trees.  简单来说，就是在子树模型分裂时，用到的特征次数。这里计算的是所有的树。这个指标在R包里也被称为frequency2。</description>
    </item>
    
    <item>
      <title>EDA 常见问题速查</title>
      <link>https://kuhungio.me/2020/eda-tricks/</link>
      <pubDate>Tue, 01 Sep 2020 12:04:49 +0800</pubDate>
      
      <guid>https://kuhungio.me/2020/eda-tricks/</guid>
      <description>标题 创建时间 发布时间 最后一次修改 备注     EDA 常见问题速查 2020.09.01 2020.12.21 2021.03.30 /     参考网站  python-graph-gallery 图之典 AntV visualcinnamon  可视化工具   seaborn
  bokeh
  chord
  pyplot
  plotly
  Datapane
  Altair
  降维
 t-SNE    三维坐标二维化 #Seaborn pair plot # source: https://stackoverflow.com/questions/52285104/3d-scatterplots-in-python-with-hue-colormap-and-legend import pandas as pd import seaborn as sns df_3d = pd.</description>
    </item>
    
    <item>
      <title>Hive 常见问题速查</title>
      <link>https://kuhungio.me/2020/hive-tricks/</link>
      <pubDate>Tue, 25 Aug 2020 11:13:05 +0800</pubDate>
      
      <guid>https://kuhungio.me/2020/hive-tricks/</guid>
      <description>标题 创建时间 发布时间 最后一次修改 备注     Hive 常见问题速查 2020.08.25 2020.12.21 2021.05.21 /     函数大全 https://www.iteblog.com/archives/2258.html
Hive 结果采样 select * from my_table where rand() &amp;lt;= 0.0001 distribute by rand() sort by rand() limit 10000; --- source: http://www.joefkelley.com/736/ 计算时间差 --- https://blog.csdn.net/kent7306/article/details/50441967 --- 计算前后差  --- https://blog.csdn.net/qq_33290422/article/details/81204532 --- 直接计算时间差 json 提取 --- refer: https://www.cnblogs.com/drjava/p/10486134.html --- [{&amp;#34;name&amp;#34;:&amp;#34;张三&amp;#34;,&amp;#34;sex&amp;#34;:&amp;#34;男&amp;#34;,&amp;#34;age&amp;#34;:&amp;#34;25&amp;#34;},{&amp;#34;name&amp;#34;:&amp;#34;李&amp;#34;,&amp;#34;sex&amp;#34;:&amp;#34;男&amp;#34;,&amp;#34;age&amp;#34;:&amp;#34;47&amp;#34;}]  SELECT get_json_object(xjson,&amp;#34;$.[0]&amp;#34;) FROM person; --- {&amp;#34;name&amp;#34;:&amp;#34;王二狗&amp;#34;,&amp;#34;sex&amp;#34;:&amp;#34;男&amp;#34;,&amp;#34;age&amp;#34;:&amp;#34;25&amp;#34;}  --- 按字段提取 SELECT get_json_object(xjson,&amp;#34;$.</description>
    </item>
    
    <item>
      <title>Model 常见问题速查</title>
      <link>https://kuhungio.me/2020/model-tricks/</link>
      <pubDate>Fri, 21 Aug 2020 11:41:15 +0800</pubDate>
      
      <guid>https://kuhungio.me/2020/model-tricks/</guid>
      <description>标题 创建时间 发布时间 最后一次修改 备注     Model 常见问题速查 2020.08.21 2020.12.21 2021.01.21 /     xgb 特征重要性 sorted_idx = np.argsort(model.feature_importances_)[::-1] ## 按重要性排序 for index in sorted_idx: print([train[feature].columns[index], model.feature_importances_[index]]) ## 绘制结果 from xgboost import plot_importance plot_importance(model, max_num_features = 15) 模型的保存与加载 import pickle pickle.dump(model, open(&amp;#34;model.pickle.dat&amp;#34;, &amp;#34;wb&amp;#34;)) model = pickle.load(open(model_path, &amp;#34;rb&amp;#34;)) 召回、准确率与阈值探查 from sklearn.metrics import precision_recall_curve,plot_precision_recall_curve # 生成预测概率 predict_pro = model.predict_proba(test[feature])[:,1:] # 生成探查 dataframe pre_recall_curve = pd.</description>
    </item>
    
    <item>
      <title>Python 常见问题速查</title>
      <link>https://kuhungio.me/2020/python-tricks/</link>
      <pubDate>Tue, 04 Aug 2020 11:39:43 +0800</pubDate>
      
      <guid>https://kuhungio.me/2020/python-tricks/</guid>
      <description>标题 创建时间 发布时间 最后一次修改 备注     Python 常见问题速查 2020.08.04 2020.12.21 2021.03.30 /     获取日期参数输入，或者默认日期 import sys import time if len(sys.argv)==2: today = sys.argv[1] else: today = time.strftime(&amp;#34;%Y-%m-%d&amp;#34;, time.localtime()) 对list元素进行判断 # source: https://thispointer.com/python-count-elements-in-a-list-that-satisfy-certain-conditions/ listOfElems = [11, 22, 33, 45, 66, 77, 88, 99, 101] # count numbers in the list which are greater than 5 count = sum(map(lambda x : x&amp;gt;5, listOfElems)) # lambda 函数可替换 print(&amp;#39;Count of numbers in a list which are greater than 5: &amp;#39;, count) str类型的array转array def str2array(current_str): &amp;#39;&amp;#39;&amp;#39; 返回数值数组 &amp;#39;&amp;#39;&amp;#39; current_array = current_str.</description>
    </item>
    
    <item>
      <title>Pandas 常见问题速查</title>
      <link>https://kuhungio.me/2020/pandas-tricks/</link>
      <pubDate>Tue, 04 Aug 2020 10:47:23 +0800</pubDate>
      
      <guid>https://kuhungio.me/2020/pandas-tricks/</guid>
      <description>标题 创建时间 发布时间 最后一次修改 备注     Pandas 常见问题速查 2020.08.04 2020.12.21 2021.01.29 /     一个 dataframe 重复多次，复制内容 n 遍 n = 3 df_repeated = pd.concat([df1]*n, ignore_index=True) 日期分箱 date_bins = pd.date_range(&amp;#39;2000-01-01&amp;#39;, freq=&amp;#39;3D&amp;#39;, periods=6) #3天一个步长，总计6个分箱 pd.cut(df.Date,bins=date_bins) pandas 去重求差集 df_a = pd.DataFrame(aa) df_b = pd.DataFrame(bb) df_a = df_a.append(df_b) df_a.drop_duplicates(subset=[&amp;#39;col_1&amp;#39;,&amp;#39;col_2&amp;#39;],keep=False) 特征相关性热力图绘制 feature_df.corr().style.background_gradient(cmap=&amp;#39;coolwarm&amp;#39;) pandas 不折叠行与列 pd.set_option(&amp;#39;display.max_rows&amp;#39;, 500) #最大行数 pd.set_option(&amp;#39;display.max_columns&amp;#39;, 500) #最大列数 pandas rename 列名 df = pd.DataFrame({&amp;#34;A&amp;#34;: [1, 2, 3], &amp;#34;B&amp;#34;: [4, 5, 6]}) df.</description>
    </item>
    
    <item>
      <title>HIVE 技巧积累之合并重叠日期</title>
      <link>https://kuhungio.me/2019/merge_overlapping_date/</link>
      <pubDate>Sun, 09 Jun 2019 00:17:05 +0800</pubDate>
      
      <guid>https://kuhungio.me/2019/merge_overlapping_date/</guid>
      <description>目前网上流传着一个段子，说算法工程师实际上就是 SQL boy，数据分析师是 PPT boy。艺术来源于现实，实际上的我们真的有很多时间在写 SQL 出数据，或者是针对 bad case 做数据的进一步分析。
这不，近期这边接到的一个需求就是对玩家的某项行为进行统计。一般来讲，掌握基本 SQL 的技巧，这些需求的难度都不大。但是这个需求需要将玩家用户的多个重叠日期进行拉伸去重。这一下可难到大伙儿。在自个儿思考无果，团队讨论之后也没啥直接的办法。
在网上搜索一番后，很多都不是很对应。不过好在几轮筛选，找到了一个类似的需求。原文链接在这里：🔗。为了方便后来的人，在这里做个分析记录，以及后面举一反三该怎么做。毕竟这些东西很少出现在教程和课本里，但是当业务方有这个需求的时候，常常又很紧急，容不得细思慢想。
问题定义： 在解决一个问题之前，我们需要先明确定义问题。这里的问题是对多个重叠日期，用 SQL 将其进行去重，并在 HIVE 环境中使用。
对于日期情况的定义 这里采用穷举法，可以得出以下13类情况：
问题简化 解决问题的核心是简化问题。这个问题看起来情况众多，实际上，对于我们的任务，只有两种情况：一个是两个日期有重叠；一个是两个日期没有重叠。
对于不同的情况，要做不同的处理。重叠日期取最大最小日期即可，非重叠的分段取。剩下的即是通过工具去实现逻辑。
数据准备 这里采用原作的方式定义数据，创建出上面的13中情况。实际上，如果你的格式和下面的类似，做出对应的调整即可。
drop table t purge; create table t ( test_case varchar2(32) not null, start_date date not null, end_date date not null ); Insert into t values (&amp;#39;01:precedes&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;01:precedes&amp;#39;,to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;04&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;02:meets&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;02:meets&amp;#39;,to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;03:overlaps&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;03:overlaps&amp;#39;,to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;04&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;04:finished by&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;04:finished by&amp;#39;,to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;05:contains&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;04&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;05:contains&amp;#39;,to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;06:starts&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;06:starts&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;07:equals&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;07:equals&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;08:started by&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;08:started by&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;09:during&amp;#39;,to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;09:during&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;04&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;10:finishes&amp;#39;,to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;10:finishes&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;11:overlapped by&amp;#39;,to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;04&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;11:overlapped by&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;12:met by&amp;#39;,to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;12:met by&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;13:preceded by&amp;#39;,to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;04&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;13:preceded by&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;)); commit; 定义出来的数据如下</description>
    </item>
    
    <item>
      <title>深度强化学习技巧 hacks for training deep RL</title>
      <link>https://kuhungio.me/2019/training_rl_systems_hacks/</link>
      <pubDate>Thu, 02 May 2019 11:59:48 +0800</pubDate>
      
      <guid>https://kuhungio.me/2019/training_rl_systems_hacks/</guid>
      <description>深度强化学习技巧 hacks for training deep RL 这是一篇旧文，John Schulman 《深度增强学习研究基础》演讲(Aug 2017)中记录的 tricks。近日重看，发现有些东西在工程中是通用的，值得一读。 测试新算法的技巧  简化问题，使用低维变量。   使用类似只有角度和速度两个变量的 Pendulum problem 问题。  这样做方便将目标函数、算法的最终状态以及算法的迭代情况可视化出来。 当出现问题时，更容易将出问题的点直观的表达（比如目标函数是否够平滑等问题）。     构造一个 demo 来测试你的算法   比如：对于一个分层强化学习算法，你应该构造一个算法可以直观学习到分层的问题。  这样能够轻易地发现那里出了问题。 注意：不要在这样的小问题上过分的尝试。    在熟悉的场景中测试   随着时间的推移，你将能预估训练所需的时间。 明白你的奖赏是如何变化的。 能够设定一个基线，以便让你知道相对过去改进了多少。 作者使用他的 hpper robot，因为他知道算法应该学多块，以及哪些行为是异常的。  快速上手新任务的技巧  简化问题   从简单的开始，直到回到问题。 途径1： 简化特征空间  举例来说，如果你是想从图片（高维空间）中学习，那么你可能先需要处理特征。举个例子：如果你的算法是想标定某个事物的位置，一开始，使用单一的x，y坐标可能会更好。 一旦起步，逐步还原问题直到解决问题。   途径2：简化奖赏函数  简化奖赏函数，这样可以有一个更快的反馈，帮助你知道是不是走偏了。 比如：击中时给 robot 记一分。这种情况很难学习，因为在开始于奖赏之前有太多的可能。将击中得分改为距离，这样将提升学习速率、更快迭代。    将一个问题转化为强化学习的技巧 可能现实是并不清楚特征是什么，也不清楚奖赏该是什么。或者，问题是什么都还不清楚。</description>
    </item>
    
    <item>
      <title>Add SSL to Your Websites</title>
      <link>https://kuhungio.me/2019/add-ssl-to-your-websites/</link>
      <pubDate>Mon, 28 Jan 2019 00:32:18 +0800</pubDate>
      
      <guid>https://kuhungio.me/2019/add-ssl-to-your-websites/</guid>
      <description>https://poplite.xyz/post/2018/05/03/how-to-enable-https-for-custom-domain-on-github-pages.html
https://www.v2ex.com/t/451406</description>
    </item>
    
    <item>
      <title>12306Bypass Server 抢票神器&#43;微信提醒</title>
      <link>https://kuhungio.me/2019/12306bypass-server/</link>
      <pubDate>Sat, 26 Jan 2019 15:52:08 +0800</pubDate>
      
      <guid>https://kuhungio.me/2019/12306bypass-server/</guid>
      <description>前言 春节假期临近，车票一度紧张。某行、某团开了加速包后，仍然无法第一时间刷到目的地的票。稍微有点儿技术底子的我们岂能坐以待毙，自然是要自己动手，丰衣足食。
网上有各类开源的工具包，这里不做过多点评。之前在好友圈内传得比较靠谱的是 12306Bypass，又叫分流。分流是一个 Windows 应用，工作在 PC 端。其核心功能完全免费，更更重要的是，它的监控刷新在本地可以真实的感知。
以前在学校还好，可以守在电脑面前。但工作后，由于各种原因，无法第一时间获取分流的抢票信息，因而白白错过好几次下单付钱的机会。于是我们就有了这样一个愿望，希望能将分流的信息第一时间转发。
前几日逛某论坛，有人向分流开发者传达了增加 Server 酱的请求。开发者还是很给力，在最近的几次版本迭代中实现了该功能。简单的来说，Server 酱就是一个提醒服务。在这里，我们把它用在抢票软件中。当软件抢到票时，通过该服务，给到微信提醒。通知我们及时付款。
通过这样的形式，即可在微信端第一时间收到下订单的信息。那么如何配置这样的一个服务呢？我们只需要以下步骤。
​
准备工作  最新版本的分流软件 搜索关键词：12306Bypass  这里使用的版本号是1.13.30。 没用过？下载链接   Github 账号 这里用做 Server 酱的登陆认证  不知道？注册链接    实操阶段 Server 酱 用于获取认证的接口
 登入：用GitHub账号 登入网站，获取SCKEY（在「发送消息」页面） 绑定：点击「微信推送」，扫码关注同时即完成绑定  记住 SCKEY ，我们接下来会用着。
分流   启动分流，按正常流程配置票务信息。
  点选主界面左下角的推送
  填入以下信息
 通知地址 `https://sc.ftqq.com/[SCKEY].send 通知参数 text=#bypass#    点击测试发送，即可在微信端，收到本文一开始的推送测试提醒啦
  实际效果 就在配置完成不久后，分流帮我抢到了回家的车票。同时在微信端，Server 酱强制推送。</description>
    </item>
    
    <item>
      <title>一场 kaggle 比赛总结出的时间序列处理技巧 time series problem summary </title>
      <link>https://kuhungio.me/2018/time-series-problem-summary/</link>
      <pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kuhungio.me/2018/time-series-problem-summary/</guid>
      <description>Source https://www.kaggle.com/c/recruit-restaurant-visitor-forecasting/discussion
总结一：保证数据同分布 验证集的选取，分布上应尽量靠近测试集。
 方式一:：对抗验证集的生成。 方式二： 就近选取相同天数。 方式三:：类比属性。如本赛题 &amp;ldquo;golden week&amp;rdquo; 与 &amp;ldquo;new year&amp;rdquo; 类比，选取 &amp;ldquo;new year&amp;rdquo; 段作为验证集。  tips: kfold 用在时间序列上不合适，会有数据泄露风险。正确的方法应是滑窗。
总结二：异常值特殊处理 一些特殊的时间节点（或者说是异常值），应该予以特殊考虑。比如本次比赛中的 &amp;ldquo;golden week&amp;rdquo;.。需要对其进行变换，而不是直接依靠模型的预测结果。
 方式一:：等同法   The rules:
Treat holiday as Saturday
If the day before holiday is weekday ,treat the day before holiday as Friday If the day after holiday is weekday ,treat the day after holiday as Monday it work not only golden week but also a lot other holidays.</description>
    </item>
    
  </channel>
</rss>