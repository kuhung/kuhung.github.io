<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术技巧 on 谷粒的博客</title>
    <link>https://kuhungio.me/categories/%E6%8A%80%E6%9C%AF%E6%8A%80%E5%B7%A7/</link>
    <description>Recent content in 技术技巧 on 谷粒的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 13 Sep 2021 09:03:51 +0800</lastBuildDate><atom:link href="https://kuhungio.me/categories/%E6%8A%80%E6%9C%AF%E6%8A%80%E5%B7%A7/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>日常冲突的解决之道</title>
      <link>https://kuhungio.me/2021/confrontation-01/</link>
      <pubDate>Mon, 13 Sep 2021 09:03:51 +0800</pubDate>
      
      <guid>https://kuhungio.me/2021/confrontation-01/</guid>
      <description>冲突管理三步骤 “不在沉默中爆发，就在沉默中灭亡。”这句话原本是周树人用来描绘旧中国反动派统治下的场景，但今天的很多场景也很适用。在人类社会中，由于各种理念的差异、资源的不均，冲突从来没有停止过。面对冲突，我们最常见的要么是沉默、要么就是爆发。
改善冲突管理技巧，对于我们的生活将大有裨益。首先，冲突很多时候是因为他人不符合自己的预期，提高冲突处理技巧能鼓舞他人对事情负责。其次，有效的冲突处理，能够给他人带来信任感，让他人更加信任你。最后，在职业生涯中，管理得当的冲突，能够给组织结构带来可预见性。
今天，我们就冲突这个话题，展开讲讲如何处理它。分为冲突之前、冲突进行中以及冲突的后管理。以下的思路框架来源于《关键冲突》，看完全文且感兴趣的同学，可以去阅读原著。
冲突之前 看到一个不合预期的情况，很多人的第一反应，大概就是直接冲上去了吧。这个反应很正常，但今天起，你应该稍微停下来，思考下：这真的是个问题吗？这个观念和《你的灯亮着吗》如出一辙。强调的是：不是所有问题都真的需要解决，也不是所有问题都需要你解决。
目标和意义 具体怎么做，首先要明白事情的目标和意义。冲突是第一次出现，那么请关注冲突的内容，不要轻易上升程度。冲突再次出现，则应关注模式。是不是什么流程出了问题？冲突多次出现，则应该关注下你和冲突方的关系了。同时审视自己，是在不该沉默的时候，选择了沉默吗？
梳理头绪 冲突面前，最应该克制的便是情绪化。情绪是一头猛兽，会干扰你的判断。如果还有第三方介入，则这个第三方可以通过操控情绪，影响你的判断。所以，请先克制住上头的感觉，克制先入为主的观念。从人、社会 以及组织的角度，综合分析影响的源头。逐步还原真相。
冲突进行时 面对冲突，首先要做到不去妄下定义。而是通过描述现状的模式，向对方询问问题的来龙去脉。
明确冲突的来源，是动机不够、还是能力不够。不同的原因有不同的应对措施。
制造动机 当对方缺少动机时，要做的是给予对方做这件事的动机。可以通过正反两种未来场景的描述，到达目的。说明目前的错误行为，对于各方的负面影响。预测正确行为将给到其他人的积极结果。最后，明确目标、责任人以及时间节点。定期检查结果。
简化问题 除了动机，能力也会影响一个人做某事的态度。你让我一个拧螺丝的去造火箭，那我即使想完成，也很难胜任不是。所以，在缺乏能力时，应尽量帮助对方简化问题。通过提问的方式，和对方一同探寻问题的根本原因。适当的，引导去关注潜在的影响因素。当能力得到匹配之后，再检查动机是否具备。
随机应变 进展不可能一帆风顺，多少你会遇到意料之外的事情。当对方感觉不安全时，先跳出话题，营造一种安全的感觉。语焉不详时，抓住这个点澄清事实。当插入突发话题时，标记好之前的话题进度，稍后回到原议题。当对方情绪化时，引导对方关注事实的经过，减少情绪化对判断的影响。
冲突之后 最后别忘了，冲突解决了不等于问题解决了。明确执行计划并跟踪进展，是善始善终的重要一环。明确何人、何时、何地做何事。明确每个人的责任和工作内容。和对方一同确定检查的时间节奏。
总结 面对冲突，核心还是在于沟通。当然，沟通也是需要技巧。以一个平等、尊重的视角，梳理冲突的经过。对差异的来源进行诊断，从能力和动机两个维度，激励他人。最后，定期检查，时刻回顾。这就是冲突处理的核心技巧。</description>
    </item>
    
    <item>
      <title>软件开发的高杠杆活动</title>
      <link>https://kuhungio.me/2021/the-effective-engineer-01/</link>
      <pubDate>Mon, 09 Aug 2021 09:12:06 +0800</pubDate>
      
      <guid>https://kuhungio.me/2021/the-effective-engineer-01/</guid>
      <description>软件开发的正确思维，聚焦高杠杆活动 作为技术序列的工程师，我时常在想，什么样的角色将会是我五年、十年后所扮演的。目前来说，工作三年有余，在某些公司内，已经可以算是高级甚至是资深工程师。不过，对于我来说，赋予title起的作用，并没有做成一件事兴奋。我时常在好奇，别的工程师的工作方法和我一样吗？我目前的工作方法是最优的了吗？
带着这样的疑问，也关注了硅谷大厂程序员的一些博客，同时也阅读了一些软件开发的经典之作，例如《人月神话》、《大教堂与旧集市》、《程序员修炼之道》等。这些内容都是很好的基础，为我软件开发的职业道路，树立了基本的职业价值观。不过今天，要推荐另外一本书《The Effective Engineer》。本书目前还没有中文版本，作者经历过硅谷的大小厂，Google、Quip、Quora等，从他的角度，总结了一些很有道理的内容。
该书的核心，聚焦在一个杠杆二字。所有活动的目的，都是最大化杠杆的效果。这点和的之前讲的财富38条法则不谋而合。在上次的法则中，同样强调了杠杆的效用。而软件开发领域，本身就是一个高杠杆活动。你开发的软件，可以只供团队内数十人使用，也可以供数以亿计的用户使用。
该系列整体分为三条，咱们逐一拆解。
软件开发的正确思维 聚焦高杠杆活动 作者认为，软件开发的核心：不是用了多么炫酷时髦的技术，不是你懂的技术别人不懂（技术垄断），而是解决业务问题。只是恰巧，工程师的角色定位，让我们能够借助软件程序解决问题。
在这个过程中，去聚焦高杠杆活动，充分发挥软件程序的优势。用杠杆率去衡量自身的产出，有计划地增加杠杆的效率。
例如：有没有方法更快完成项目？有没有方法让项目的作用更大？如果不做这个项目，有没有其他杠杆率更高的项目？
优化学习 这里的核心观点在于，学习是存在复利效应的。无论外界如何变化，一定要掌握自己的学习节奏。寻找能够提供成长的环境，结合工作中的其他人的能力，提升自己的能力。除了工作内容，工作外的技能也应有所精进。
更迭优先级 我们都知道，事情可以根据四象限法则，分为重要紧急、重要不紧急、不重要紧急、不重要不紧急。最后一个能不做就不做，倒数第二个能晚做就晚做。前面两个优先做，重点做。
在这一环节，聚焦能够直接产生价值的地方。如果担心被打扰，则可以设置一个番茄闹钟，以减少场景切换的可能。为了减缓拖延，可通过自我目标设定，自我陈述的方式：”如果，就“来有序安排工作。
在执行上下功夫 投资迭代 在软件开发领域，有一个著名的MVP理论，即最小可行性原型。该方法除了快速验证假设外，也起到快速迭代的作用。迭代越快，我们能学到的就越多。熟练掌握工作，多在迭代上下功夫。
测量指标 没有测量，就没有改进。这是著名管理学理论。在软件开发领域也是如此。当然，衡量程序员的产出，不是靠代码行数或者bug数，而是其实际的产出价值。这也要求我们谨慎地选择衡量指标。理解数字，诚实看待数字。
尽早验证想法 一如前面的MVP原则，我们尽早验证想法，通过迭代减少浪费。如果有必要，我们还可以通过A/B测试，来检验实际效果。
项目评估技巧 大部分时间，我们也会面临项目周期评估的问题。作者建议，在排期中设立回旋余地。拆分项目，设置合理的里程碑。优先处理高风险的事项，能一定程度保证项目如期交付。如果延期不可避免，则也应该对延期时间有个合理的评估。
构建长期价值 实用与质量的平衡 多快好省赶紧上，这种思想也会出现在软件开发领域。这本身与快速迭代并不矛盾，但要注意平衡好开发周期与质量的矛盾。CodeReview、自动化测试，能够一定程度减少出错概率。项目发展过程中的技术债，要得到有效管理。不可一味堆叠需求而忽视技术基建。
减少维护成本 在项目上线的维护过程中，也需要留意维护的成本。开发代码过程中，将错误有效暴露。同时进行链路上的故障演习，合理安排兜底策略，将有效减少维护成本。
投资团队成长 从长远来看，每个人都不可能单兵作战取得巨大的成功，我们需要团队。投资团队成长方面，首先是帮助其他人成功。这可以通过分享自己的经验，写下高质量的文档实现。也可通过CodeReview实现。另一方面，招聘是团队内每个人的责任。招聘高质量的同事，在入职培训和指导方面下功夫，也将获得极大的回报。
关于作者</description>
    </item>
    
    <item>
      <title>工程师如何卖轮子</title>
      <link>https://kuhungio.me/2021/selling-the-wheel/</link>
      <pubDate>Tue, 25 May 2021 21:53:20 +0800</pubDate>
      
      <guid>https://kuhungio.me/2021/selling-the-wheel/</guid>
      <description>在互联网行业，常常听见人说：我有个点子，只是缺少一个程序员，就能颠覆世界。不过遗憾的是，很多组织即使有很多程序员，也未能颠覆世界。无数的点子被证明是无效的，无人买单。用户不关心、客户不掏钱。
上面是普通人的技术产品主张。作为程序员自己，是不是就没有这样的困扰了呢？我们可以做前端、可以做web端、可以开发自己的小程序，是不是就可以吸引无数忠实用户、卖个好价钱、躺平后半生了呢？如果真是这样子，那大概996和秃头就是假的、是拜登打的劳工牌了。
除了技术力，市场的敏锐度以及营销能力，也是决定成败的关键。
在日常工作中，不可避免的，程序开发也会有自己的观点主张：无论是技术方面的、还是日常决策方向的。也有人幻想着，有个赏识的伯乐，能发现自己点子的独特之处，然后悄悄”颠覆世界“。
技术同事能听出哪些点子是不现实的，同样，”伯乐“也能识别出你的技术主张的好坏。这个时候该怎么办呢，产品太超前、主张”非主流“，难道就要放弃了吗？求人不如求己。
推销是一门艺术。作为价值提供者，我们有必要做好自己的营销推广。除非，你想一直当一个工具人下去。我们希望，在合适的推销之下，产品能卖出去、技术方案能得到接纳，观点主张能得到重视。这一切，其实都不难。
近期阅读了一本名为《selling the wheel》（中文名《卖轮子》）的书，该书虚拟架空了一个埃及人卖轮子的故事。讲述从发明轮子，到销售推广，再到竞争市场的各个环节。以及对应市场下，如何构建适合的销售体系。这套方法，不仅可以用来卖产品，完全也可以整合到我们自身的日常生活中来，销售我们的观点、技术与方案。
如果你也想做好自身观点、技术和产品的宣传，那么下面的内容一定不要错过。
市场上没有一套通吃的办法。这是因为随着市场成熟度的不同，受众和他们的认知程度也不一样。但好在在不同阶段，有各自能做的事。我们以产品的发展周期为例，讲述四个时间段我们该做的事情。
一、市场早期 当市场还是蓝海之时，很少有人意识到这是个机会。客户也是同样如此，他不会觉得有你很重要。因为当你没出现时，他已经按某种模式度过了很多年。在轮子出现前，古埃及人一样可以运送货物。他们可以选择用人拉、用动物驮，甚至是用雪橇拉。为什么他们要选择你呢？
在产品的早期，往往是一些尝鲜的用户接纳它们。在四步创业中，我们也可称之为天使用户。在技术接纳生命周期中，他们是技术和产品的尝鲜者。天使用户乐于追逐新鲜事物，是你最好的销售目标。他们聪明、敢于尝鲜，敢冒险，有资本。
销售对象是最高决策者，一般是一次性买卖。如果想要卖给他们，则应该强调某些特质，而这些正是他们所追逐的：领先于人的机会和洞察，一个更高效的、更美好的未来。对于销售者，则是需要极强的人格魅力。相信产品，用华丽的演示征服他人。
新技术、新产品、新观念 这一阶段，是我们最常遇到的阶段，特别是进入新公司和新项目中时。技术人员在公司内拥有较为时髦的技术，知道当下技术发展的潮流。也因为掌握技术，能较为轻易的了解到最新潮的观念。以数据挖掘为例，我们有很多模型方法，已经在顶刊、比赛甚至是其它公司的业务场景中得到应用。
在公司内进行推广时，往往不会一帆风顺。因为当你没出现时，业务方已经熟练的用其它方法解决了问题，尽管它可能没你的好。
这个时候，同上面一样，我们要去识别公司内的那些天使客户，将技术的前景销售给他们，打开应用市场。该阶段，我们常常是单兵作战，将我们的方案推销给有决策权、聪明且有冒险精神的业务方。推销一种概念，而不是一种产品或服务。以理性阐释购买，以情感卖出产品。
二、市场发育 渐渐地，天使用户口碑传播了你的产品（只要你的产品值得他向朋友推荐）。越来越多的用户开始使用你的产品，他们会拿来做不同的用途，甚至有些超乎你意料。轮子是好的交通工具，但同时，两个石头轮子叠在一起，他也可以拿来做磨坊，高效地碾碎玉米。产品被越来越多的高层技术人员使用。他们不再是单一的拿来应用，而是借助产品，实现他们的整体目标。
所以，单纯的轮子已经不够用了。金字塔的建造工程师希望我们给到完成的方案，能够支持他们建设金字塔的工作。我们不再是仅仅销售轮子，更是在于轮子的安装、使用、保养等专业性知识。我们的销售对象，也不再局限于直接最高决策者，而是所有影响决策的人，与团队合作。我们销售的是整体解决方案，而不再是单一的产品，客户需要一整套方案，帮助他们实现美好目标。
在这种背景下，常常需要一个团队来支持。提供产品的售后、服务以及培训等事宜。销售周期也更长。我们就像是向导，不仅需要告诉客户目标在哪里，还要引导和带领他们。销售产品的同时，培训客户，构建良好的合作伙伴关系。
全套解决方案 在公司内也是如此，当我们的方案被更多人接纳时，将会出现不一样的需求和用户。有的可能只是单纯的需要个分类工具，有的开始拿你的产品或技术做其它的事情。我们不再是单打独斗，常常需要一个小团队一起工作，帮助业务方完成整体目标。
这个阶段，业务方需要的也不是单一的技术或工具，他们希望你去培训他们掌握该项技能、或是能提供长久的维护。所以，尽量提供更多的支持，帮助业务方实现共同目标。从目标出发，落地到对方的业务价值，能帮助你做出正确的决策。提供适当指引和培训，构建良好的合作关系，是当下阶段的重点。
这个阶段最大风险是花费资源做没有被接受的技术。为了减少风险，应当适当地多同步进展，寻求业务方的反馈，根据反馈及时进行资源调整。
三、市场竞争 产品是打开了销路，但不可避免的，你会和其它产品产生替代性冲突。更甚至，市面上开始出现仿冒的产品。轮子开始出现木制、出现条幅。他们更灵活、更便宜，技术不再是唯一的壁垒。大家也逐渐熟悉了有你的日子，但不同产品间仍有细微差别。这个时候，你的销售对象，应该是稳定的采购单位。他们在各大组织和机构中，你们在之前应该已经建立了稳固的合作关系。
客户开始有了其它需要满足的诉求，产品在这个阶段开始出现定制化。我们如同建设者，为我们最核心的客户，提供最优质的服务。尽管在第一阶段，天使客户也有可能提出他的各种想法，但真正值得响应的，却是这个阶段。因为在初期阶段，满足少量的额外需求，很可能带来频繁的调整以至于产品走向错误。一般客户只获得一般服务。
这个阶段，产品销售的周期大幅度拉长。产品开始同质化、价格战开始出现，利润下降。树立自己的品牌、扩大生产规模，是维持利润的两种手段。有些市场你已经撼动不了，短时间插足不了。但记得保持关注，竞争对手犯错之时，就是你最好的机会。
定制服务与品牌传播 在公司一段时间之后，只要你平稳度过前面两个阶段，大概率也会到这个阶段。你的技术方案、你的产品很可能同别的团队产生可替代性竞争。同时也被越来越多的人员和团队使用。
这个阶段，我们得针对需求方，提供定制化服务。通过评估核心重要程度和ROI，去满足他们的定制化需求。
树立团队口碑，扩大影响力，是获得需求的来源之一。压缩成本和工期，一味迎合所有业务方，是失败的快速通道。**你的团队伙伴，是你的重要资产和坚实靠山。**对于一些暂时无法接入的业务，维护好和客户的关系，等待机会即可。
四、市场支配 最后阶段，即是红海市场。这也属我们所接触的民用消费市场最典型。产品出现同一标准，轮子有了半径、材质、使用寿命等要求。顾客不再像早期顾客，犹豫徘徊。他们很快做出决策，而他们所依赖的，则是品牌和服务。
这个阶段，利润被进一步摊薄。产品的品牌和服务成为了竞争的主要手段。促销开始越来越常见，连锁经验、标准化服务成为标配。
由销售leader领导的销售团队，提供细致的售前和售后服务。进行充分技术培训，激发员工热情，能妥善应对突发事件。
个人品牌与综合素质 如果你的公司不是toB业务，那么较小概率会到这一步。对于平台、中台类项目，更多的还是在上一步。如果你在此类公司，那么标准化服务可能是你重点关注的东西。
但是换个角度，如果我们抽离产品和公司的框架，我们的观点和主张所处的环境，难道不是在充分竞争的市场中吗？普世价值和道德选择，都有基本的标准。沟通的对象很快做出决策，依赖你的声誉和给人的感受。
过硬的专业素质，热情，同理心，以及移情的能力，就是你的标准化服务。你的个人品牌和综合素质，成为你的竞争利器。
总结 产品阶段组合 以上四种方式可以组合。
1+2 适合小而灵活的创业公司，技术进步，创业不歇。
2+3 能带来高利润增长。新兴技术被发掘，被改善，然后再批量投入市场。
3+4 则是市场支配地位的公司做的事情，缓慢、稳定可预见的增长。通过兼并获得新技术。
一般而言，前者的利润是后者的两倍。
个人营销三部曲 把大象放进冰箱，需要三步。如何推销你的产品、技术与方案，同样也是三步。
判断所处环境
锁定目标客户
提供对应销售方法
掌握以上方法，推销你的观点、技术与产品，将没那么难。
Tips：
营销六问
谁是我们的客户？
谁是我们的竞争对手？
客户为什么需要我们的产品？
什么促使他们更愿意从我们这里购买？
为什么他们愿意从竞争对手处购买？
我们应提供哪些增值服务以达成交易？</description>
    </item>
    
    <item>
      <title>Xgboost 三种特征重要性计算方法对比与扩展</title>
      <link>https://kuhungio.me/2021/three-feature-importances-in-xgb/</link>
      <pubDate>Mon, 08 Mar 2021 21:09:31 +0800</pubDate>
      
      <guid>https://kuhungio.me/2021/three-feature-importances-in-xgb/</guid>
      <description>简单描述 实际发布 最后一次修改 xgb 特征重要性计算方法及使用场景 2021-03-08 2021-03-09 特征重要性 作用与来源 特征重要性，我们一般用来观察不同特征的贡献度。排名靠前的，我们自然而然地认为，它是重要的。
这一思路，通常被用来做特征筛选。剔除贡献度不高的尾部特征，增强模型的鲁棒性的同时，起到特征降维的作用。
另一个方面，则是用来做模型的可解释性。我们期望的结果是：重要的特征是符合业务直觉的；符合业务直觉的特征排名靠前。
在实际操作中，我们一般用树模型的分类节点做文章。常用的就是 XGB 和其他一般树模型。
XGB 遇到的问题 XGB 很方便，不仅是比赛的大杀器，甚至贴心的内置了重要性函数。但在实际使用过程中，常常陷入迷思。
有如下几个点的顾虑：
这些特征重要性是如何计算得到的？ 为什么特征重要性不同？ 什么情况下采用何种特征重要性合适？ 今天我们就借这篇文章梳理一下。
XGB 中常用的三种特征重要性计算方法，以及它的使用场景。除此之外，再看两个第三方的特征重要性计算方法，跳出内置函数，思考其中的差异。
最后回到类似的树模型特征计算方法，进行特征重要性的一般方法总结。
以下场景非特殊说明，均针对 python 包体下的 xgb 和sklearn。
XGB 内置的三种特征重要性计算方法1 weight xgb.plot_importance 这是我们常用的绘制特征重要性的函数方法。其背后用到的贡献度计算方法为weight。
‘weight’ - the number of times a feature is used to split the data across all trees. 简单来说，就是在子树模型分裂时，用到的特征次数。这里计算的是所有的树。这个指标在R包里也被称为**frequency**2。
gain model.feature_importances_ 这是我们调用特征重要性数值时，用到的默认函数方法。其背后用到的贡献度计算方法为gain。
‘gain’ - the average gain across all splits the feature is used in.</description>
    </item>
    
    <item>
      <title>EDA 常见问题速查</title>
      <link>https://kuhungio.me/2020/eda-tricks/</link>
      <pubDate>Tue, 01 Sep 2020 12:04:49 +0800</pubDate>
      
      <guid>https://kuhungio.me/2020/eda-tricks/</guid>
      <description>标题 创建时间 发布时间 最后一次修改 备注 EDA 常见问题速查 2020.09.01 2020.12.21 2021.03.30 / 参考网站 python-graph-gallery 图之典 AntV visualcinnamon 可视化工具 seaborn
bokeh
chord
pyplot
plotly
Datapane
Altair
降维
t-SNE 三维坐标二维化 #Seaborn pair plot # source: https://stackoverflow.com/questions/52285104/3d-scatterplots-in-python-with-hue-colormap-and-legend import pandas as pd import seaborn as sns df_3d = pd.DataFrame() df_3d[&amp;#39;x&amp;#39;] = x df_3d[&amp;#39;y&amp;#39;] = y df_3d[&amp;#39;z&amp;#39;] = z sns.pairplot(df_3d) 韦恩图绘制 matplotlib-venn
from matplotlib_venn import venn2 venn2([set([&amp;#39;A&amp;#39;, &amp;#39;B&amp;#39;, &amp;#39;C&amp;#39;, &amp;#39;D&amp;#39;]), set([&amp;#39;D&amp;#39;, &amp;#39;E&amp;#39;, &amp;#39;F&amp;#39;])]) def plot_venn(col_1,col_2): set_1 = set(col_1) print(len(set_1)) set_2 = set(col_2) print(len(set_2)) venn2([set_1,set_2]) seaborn 加 title # refer https://stackoverflow.</description>
    </item>
    
    <item>
      <title>Hive 常见问题速查</title>
      <link>https://kuhungio.me/2020/hive-tricks/</link>
      <pubDate>Tue, 25 Aug 2020 11:13:05 +0800</pubDate>
      
      <guid>https://kuhungio.me/2020/hive-tricks/</guid>
      <description>标题 创建时间 发布时间 最后一次修改 备注 Hive 常见问题速查 2020.08.25 2020.12.21 2021.08.10 / 函数大全 https://www.iteblog.com/archives/2258.html
Hive 结果采样 select * from my_table where rand() &amp;lt;= 0.0001 distribute by rand() sort by rand() limit 10000; --- source: http://www.joefkelley.com/736/ hive 填补空值 --- https://stackoverflow.com/questions/63891981/sql-hive-replace-null-values-with-0-hadoop-hive select coalesce(t2.Apple, 0) as apple from table; hive 分箱 # https://www.jianshu.com/p/a67280db6b33 -- Ntile(n) over(order by col)：分块函数 -- 备注：NULL值的处理，是否需要单独为1组。 select col -- NULL默认为最小值 , ntile(2) over( order by col) as group1 -- 将NULL单独为1组 , if(col is null, null, ntile(2) over( partition by if(col is null, 1, 0) order by col) as group2 from( select cast(col as int) as col from( select stack(5, &amp;#39;NULL&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;, &amp;#39;3&amp;#39;, &amp;#39;4&amp;#39;) as col ) as a ) as a 计算时间差 --- https://blog.</description>
    </item>
    
    <item>
      <title>Model 常见问题速查</title>
      <link>https://kuhungio.me/2020/model-tricks/</link>
      <pubDate>Fri, 21 Aug 2020 11:41:15 +0800</pubDate>
      
      <guid>https://kuhungio.me/2020/model-tricks/</guid>
      <description>标题 创建时间 发布时间 最后一次修改 备注 Model 常见问题速查 2020.08.21 2020.12.21 2022.01.03 / xgb 特征重要性 sorted_idx = np.argsort(model.feature_importances_)[::-1] ## 按重要性排序 for index in sorted_idx: # print([train[feature].columns[index], model.feature_importances_[index]]) print([features[index], model.feature_importances_[index]]) ## 打印结果 [round(elem, 3) for elem in model.feature_importances_] ## 绘制结果 from xgboost import plot_importance plot_importance(model, max_num_features = 15) ## ps：引入随机列 import numpy as np df1[&amp;#39;randNumCol&amp;#39;] = np.random.randint(1, 6, df1.shape[0]) 模型的保存与加载 import pickle pickle.dump(model, open(&amp;#34;model.pickle.dat&amp;#34;, &amp;#34;wb&amp;#34;)) model = pickle.load(open(model_path, &amp;#34;rb&amp;#34;)) 召回、准确率与阈值探查 from sklearn.metrics import precision_recall_curve,plot_precision_recall_curve # 生成预测概率 predict_pro = model.</description>
    </item>
    
    <item>
      <title>Python 常见问题速查</title>
      <link>https://kuhungio.me/2020/python-tricks/</link>
      <pubDate>Tue, 04 Aug 2020 11:39:43 +0800</pubDate>
      
      <guid>https://kuhungio.me/2020/python-tricks/</guid>
      <description>标题 创建时间 发布时间 最后一次修改 备注 Python 常见问题速查 2020.08.04 2020.12.21 2021.03.30 / 获取日期参数输入，或者默认日期 import sys import time if len(sys.argv)==2: today = sys.argv[1] else: today = time.strftime(&amp;#34;%Y-%m-%d&amp;#34;, time.localtime()) 日期加减操作 from datetime import datetime, timedelta def date_transfer(today): today = datetime.strptime(today, &amp;#34;%Y-%m-%d&amp;#34;) yesterday = today - timedelta(days=1) return today.strftime( &amp;#34;%Y-%m-%d&amp;#34;),yesterday.strftime( &amp;#34;%Y-%m-%d&amp;#34;) 对list元素进行判断 # source: https://thispointer.com/python-count-elements-in-a-list-that-satisfy-certain-conditions/ listOfElems = [11, 22, 33, 45, 66, 77, 88, 99, 101] # count numbers in the list which are greater than 5 count = sum(map(lambda x : x&amp;gt;5, listOfElems)) # lambda 函数可替换 print(&amp;#39;Count of numbers in a list which are greater than 5: &amp;#39;, count) str类型的array转array def str2array(current_str): &amp;#39;&amp;#39;&amp;#39; 返回数值数组 &amp;#39;&amp;#39;&amp;#39; current_array = current_str.</description>
    </item>
    
    <item>
      <title>Pandas 常见问题速查</title>
      <link>https://kuhungio.me/2020/pandas-tricks/</link>
      <pubDate>Tue, 04 Aug 2020 10:47:23 +0800</pubDate>
      
      <guid>https://kuhungio.me/2020/pandas-tricks/</guid>
      <description>标题 创建时间 发布时间 最后一次修改 备注 Pandas 常见问题速查 2020.08.04 2020.12.21 2021.06.09 / 一个 dataframe 重复多次，复制内容 n 遍 n = 3 df_repeated = pd.concat([df1]*n, ignore_index=True) 日期分箱 date_bins = pd.date_range(&amp;#39;2000-01-01&amp;#39;, freq=&amp;#39;3D&amp;#39;, periods=6) #3天一个步长，总计6个分箱 pd.cut(df.Date,bins=date_bins) pandas 去重求差集 df_a = pd.DataFrame(aa) df_b = pd.DataFrame(bb) df_a = df_a.append(df_b) df_a.drop_duplicates(subset=[&amp;#39;col_1&amp;#39;,&amp;#39;col_2&amp;#39;],keep=False) 特征相关性热力图绘制 feature_df.corr().style.background_gradient(cmap=&amp;#39;coolwarm&amp;#39;) pandas 不折叠行与列 pd.set_option(&amp;#39;display.max_rows&amp;#39;, 500) #最大行数 pd.set_option(&amp;#39;display.max_columns&amp;#39;, 500) #最大列数 pandas rename 列名 df = pd.DataFrame({&amp;#34;A&amp;#34;: [1, 2, 3], &amp;#34;B&amp;#34;: [4, 5, 6]}) df.rename(columns={&amp;#34;A&amp;#34;: &amp;#34;a&amp;#34;, &amp;#34;B&amp;#34;: &amp;#34;c&amp;#34;}) 强制关闭 copy warning # source: https://zhuanlan.</description>
    </item>
    
    <item>
      <title>HIVE 技巧积累之合并重叠日期</title>
      <link>https://kuhungio.me/2019/merge_overlapping_date/</link>
      <pubDate>Sun, 09 Jun 2019 00:17:05 +0800</pubDate>
      
      <guid>https://kuhungio.me/2019/merge_overlapping_date/</guid>
      <description>目前网上流传着一个段子，说算法工程师实际上就是 SQL boy，数据分析师是 PPT boy。艺术来源于现实，实际上的我们真的有很多时间在写 SQL 出数据，或者是针对 bad case 做数据的进一步分析。
这不，近期这边接到的一个需求就是对玩家的某项行为进行统计。一般来讲，掌握基本 SQL 的技巧，这些需求的难度都不大。但是这个需求需要将玩家用户的多个重叠日期进行拉伸去重。这一下可难到大伙儿。在自个儿思考无果，团队讨论之后也没啥直接的办法。
在网上搜索一番后，很多都不是很对应。不过好在几轮筛选，找到了一个类似的需求。原文链接在这里：🔗。为了方便后来的人，在这里做个分析记录，以及后面举一反三该怎么做。毕竟这些东西很少出现在教程和课本里，但是当业务方有这个需求的时候，常常又很紧急，容不得细思慢想。
问题定义： 在解决一个问题之前，我们需要先明确定义问题。这里的问题是对多个重叠日期，用 SQL 将其进行去重，并在 HIVE 环境中使用。
对于日期情况的定义 这里采用穷举法，可以得出以下13类情况：
问题简化 解决问题的核心是简化问题。这个问题看起来情况众多，实际上，对于我们的任务，只有两种情况：一个是两个日期有重叠；一个是两个日期没有重叠。
对于不同的情况，要做不同的处理。重叠日期取最大最小日期即可，非重叠的分段取。剩下的即是通过工具去实现逻辑。
数据准备 这里采用原作的方式定义数据，创建出上面的13中情况。实际上，如果你的格式和下面的类似，做出对应的调整即可。
drop table t purge; create table t ( test_case varchar2(32) not null, start_date date not null, end_date date not null ); Insert into t values (&amp;#39;01:precedes&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;01:precedes&amp;#39;,to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;04&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;02:meets&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;02:meets&amp;#39;,to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;03:overlaps&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;03:overlaps&amp;#39;,to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;04&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;04:finished by&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;04:finished by&amp;#39;,to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;05:contains&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;04&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;05:contains&amp;#39;,to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;06:starts&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;06:starts&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;07:equals&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;07:equals&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;08:started by&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;08:started by&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;09:during&amp;#39;,to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;09:during&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;04&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;10:finishes&amp;#39;,to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;10:finishes&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;11:overlapped by&amp;#39;,to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;04&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;11:overlapped by&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;12:met by&amp;#39;,to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;12:met by&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;13:preceded by&amp;#39;,to_date(&amp;#39;03&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;04&amp;#39;,&amp;#39;DD&amp;#39;)); Insert into t values (&amp;#39;13:preceded by&amp;#39;,to_date(&amp;#39;01&amp;#39;,&amp;#39;DD&amp;#39;),to_date(&amp;#39;02&amp;#39;,&amp;#39;DD&amp;#39;)); commit; 定义出来的数据如下</description>
    </item>
    
    <item>
      <title>深度强化学习技巧 hacks for training deep RL</title>
      <link>https://kuhungio.me/2019/training_rl_systems_hacks/</link>
      <pubDate>Thu, 02 May 2019 11:59:48 +0800</pubDate>
      
      <guid>https://kuhungio.me/2019/training_rl_systems_hacks/</guid>
      <description>深度强化学习技巧 hacks for training deep RL 这是一篇旧文，John Schulman 《深度增强学习研究基础》演讲(Aug 2017)中记录的 tricks。近日重看，发现有些东西在工程中是通用的，值得一读。 测试新算法的技巧 简化问题，使用低维变量。 使用类似只有角度和速度两个变量的 Pendulum problem 问题。 这样做方便将目标函数、算法的最终状态以及算法的迭代情况可视化出来。 当出现问题时，更容易将出问题的点直观的表达（比如目标函数是否够平滑等问题）。 构造一个 demo 来测试你的算法 比如：对于一个分层强化学习算法，你应该构造一个算法可以直观学习到分层的问题。 这样能够轻易地发现那里出了问题。 注意：不要在这样的小问题上过分的尝试。 在熟悉的场景中测试 随着时间的推移，你将能预估训练所需的时间。 明白你的奖赏是如何变化的。 能够设定一个基线，以便让你知道相对过去改进了多少。 作者使用他的 hpper robot，因为他知道算法应该学多块，以及哪些行为是异常的。 快速上手新任务的技巧 简化问题 从简单的开始，直到回到问题。 途径1： 简化特征空间 举例来说，如果你是想从图片（高维空间）中学习，那么你可能先需要处理特征。举个例子：如果你的算法是想标定某个事物的位置，一开始，使用单一的x，y坐标可能会更好。 一旦起步，逐步还原问题直到解决问题。 途径2：简化奖赏函数 简化奖赏函数，这样可以有一个更快的反馈，帮助你知道是不是走偏了。 比如：击中时给 robot 记一分。这种情况很难学习，因为在开始于奖赏之前有太多的可能。将击中得分改为距离，这样将提升学习速率、更快迭代。 将一个问题转化为强化学习的技巧 可能现实是并不清楚特征是什么，也不清楚奖赏该是什么。或者，问题是什么都还不清楚。
第一步：将这个问题使用随机策略可视化出来。 看看那些部分吸引了你。
如果这个随机策略在某些情况下做了正确的事，那么很大概率，强化学习也可以做到。
策略的更新将会发现这里面的行为，并促使稳定下来。 如果随机策略永远都做不到，那么强化学习也不可能。 确保可观测 确保你能够掌控系统，且给 agent 的也是同样的系统环境。 举个例子： 亲自查看处理过图片，以确保你没有移出掉关键信息或者是在某种程度上阻碍算法。 确保所有的事物都在合理的尺度 经验法则： 观测环境： 确保均值为0，方差为1。 奖赏： 如果你能控制它，就把他缩放到一个合理的维度。 在所有的数据上都做同样的处理。 检查所有的观测环境以及奖赏，以确保没有特别离奇的异常值。 建立一个好的基线 一开始并不清楚哪些算法会起作用，所以设定一系列的基线（从其他方法）。 交叉熵 策略更新 一些类型的 Q-learning 算法: OpenAI Baselines 或者 RLLab 复现论文 某些时候（经常的事），复现论文结果特别困难。有如下一些技巧：</description>
    </item>
    
    <item>
      <title>Add SSL to Your Websites</title>
      <link>https://kuhungio.me/2019/add-ssl-to-your-websites/</link>
      <pubDate>Mon, 28 Jan 2019 00:32:18 +0800</pubDate>
      
      <guid>https://kuhungio.me/2019/add-ssl-to-your-websites/</guid>
      <description>https://poplite.xyz/post/2018/05/03/how-to-enable-https-for-custom-domain-on-github-pages.html
https://www.v2ex.com/t/451406</description>
    </item>
    
    <item>
      <title>12306Bypass Server 抢票神器&#43;微信提醒</title>
      <link>https://kuhungio.me/2019/12306bypass-server/</link>
      <pubDate>Sat, 26 Jan 2019 15:52:08 +0800</pubDate>
      
      <guid>https://kuhungio.me/2019/12306bypass-server/</guid>
      <description>前言 春节假期临近，车票一度紧张。某行、某团开了加速包后，仍然无法第一时间刷到目的地的票。稍微有点儿技术底子的我们岂能坐以待毙，自然是要自己动手，丰衣足食。
网上有各类开源的工具包，这里不做过多点评。之前在好友圈内传得比较靠谱的是 12306Bypass，又叫分流。分流是一个 Windows 应用，工作在 PC 端。其核心功能完全免费，更更重要的是，它的监控刷新在本地可以真实的感知。
以前在学校还好，可以守在电脑面前。但工作后，由于各种原因，无法第一时间获取分流的抢票信息，因而白白错过好几次下单付钱的机会。于是我们就有了这样一个愿望，希望能将分流的信息第一时间转发。
前几日逛某论坛，有人向分流开发者传达了增加 Server 酱的请求。开发者还是很给力，在最近的几次版本迭代中实现了该功能。简单的来说，Server 酱就是一个提醒服务。在这里，我们把它用在抢票软件中。当软件抢到票时，通过该服务，给到微信提醒。通知我们及时付款。
通过这样的形式，即可在微信端第一时间收到下订单的信息。那么如何配置这样的一个服务呢？我们只需要以下步骤。
​
准备工作 最新版本的分流软件 搜索关键词：12306Bypass 这里使用的版本号是1.13.30。 没用过？下载链接 Github 账号 这里用做 Server 酱的登陆认证 不知道？注册链接 实操阶段 Server 酱 用于获取认证的接口
登入：用GitHub账号 登入网站，获取SCKEY（在「发送消息」页面） 绑定：点击「微信推送」，扫码关注同时即完成绑定 记住 SCKEY ，我们接下来会用着。
分流 启动分流，按正常流程配置票务信息。
点选主界面左下角的推送
填入以下信息
通知地址 `https://sc.ftqq.com/[SCKEY].send 通知参数 text=#bypass# 点击测试发送，即可在微信端，收到本文一开始的推送测试提醒啦
实际效果 就在配置完成不久后，分流帮我抢到了回家的车票。同时在微信端，Server 酱强制推送。
总结 通过这样的一番配置，我们终于能够安稳的玩耍手机，而不用担心错过订单付款时间。事实上，分流本身的基础功能，也自带了一些提醒服务。但是他们大多较为繁琐。以 QQ 提醒为例，有被顶掉下线的风险。自带的微信提醒，模拟的微信桌面登陆，理论上需要2个微信号。按照上面的操作，我们只需要简单的配置，即可实现强制推送，错过的几率大大减小。
这样的推送服务，其应用场景不局限于此。这也是我琢磨它的原因之一——应用场景广泛。只要需要推送的地方，都可以嵌入这样一套服务。例如网站新增评论、或是按秒计费的服务器上模型训练结束等等。
Server 酱实现的功能有限，仅针对微信推送。但这也是它针对国内业务的一种优化。类似这样的推送服务很多，国外的 Slack 功能组件也很丰富。在一些涉及敏感信息的领域，构建一套自己的推送服务，也是不错的主意。</description>
    </item>
    
    <item>
      <title>一场 kaggle 比赛总结出的时间序列处理技巧 time series problem summary </title>
      <link>https://kuhungio.me/2018/time-series-problem-summary/</link>
      <pubDate>Thu, 08 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kuhungio.me/2018/time-series-problem-summary/</guid>
      <description>Source https://www.kaggle.com/c/recruit-restaurant-visitor-forecasting/discussion
总结一：保证数据同分布 验证集的选取，分布上应尽量靠近测试集。
方式一:：对抗验证集的生成。 方式二： 就近选取相同天数。 方式三:：类比属性。如本赛题 &amp;ldquo;golden week&amp;rdquo; 与 &amp;ldquo;new year&amp;rdquo; 类比，选取 &amp;ldquo;new year&amp;rdquo; 段作为验证集。 tips: kfold 用在时间序列上不合适，会有数据泄露风险。正确的方法应是滑窗。
总结二：异常值特殊处理 一些特殊的时间节点（或者说是异常值），应该予以特殊考虑。比如本次比赛中的 &amp;ldquo;golden week&amp;rdquo;.。需要对其进行变换，而不是直接依靠模型的预测结果。
方式一:：等同法 The rules:
Treat holiday as Saturday
If the day before holiday is weekday ,treat the day before holiday as Friday If the day after holiday is weekday ,treat the day after holiday as Monday it work not only golden week but also a lot other holidays.</description>
    </item>
    
  </channel>
</rss>
